// @ts-check

const crawl = require("./crawl.cjs");
const { readFileSync, writeFileSync, existsSync } = require("fs");
const { resolve } = require("path");

/** @type { import("terser").MinifyOptions } */
const TERSER_OPTIONS = {
  compress: {
    booleans_as_integers: false,
    ecma: 2020,
    expression: true,
    keep_fargs: false,
    passes: 3,
    unused: false,
  },
  format: {
    comments: false,
    indent_level: 0,
  },
};
/** @type { import("html-minifier-terser").Options } */
const HTML_TERSER_OPTIONS = {
  collapseBooleanAttributes: true,
  collapseInlineTagWhitespace: true,
  collapseWhitespace: true,
  conservativeCollapse: false,
  includeAutoGeneratedTags: false,
  minifyCSS: true,
  minifyJS: TERSER_OPTIONS,
  minifyURLs: true,
  noNewlinesBeforeTagClose: true,
  removeAttributeQuotes: true,
  removeComments: true,
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
};

const { minify_sync: terser_minify } = require("terser");
const { minify: html_terser_minify } = require("html-minifier-terser");

const FILES = {
  JS: /\.c?js$/,
  HTML: /\.html$/,
  CSS: /\.css$/,
};

/**
 * @param { string } unresolvedBuildDirectory
 */
async function minify(unresolvedBuildDirectory) {
  const buildDirectory = resolve(__dirname, "../", unresolvedBuildDirectory);

  if (!existsSync(buildDirectory)) {
    throw new Error(`Directory ${buildDirectory} does not exist`);
  }

  const files = crawl(buildDirectory, "files").filter(
    (file) =>
      FILES.JS.test(file) || FILES.HTML.test(file) || FILES.CSS.test(file)
  );

  for (const file of files) {
    console.log(
      `[minify] | Minifying ${unresolvedBuildDirectory + file.slice(buildDirectory.length)}`
    );

    const fileContents = readFileSync(file, "utf-8");
    const minified = await (FILES.JS.test(file)
      ? minifyJS(fileContents)
      : FILES.HTML.test(file)
        ? minifyHTML(fileContents)
        : minifyCSS(fileContents));

    if (minified === null) {
      console.warn(`Could not minify file ${file}.`);
      continue;
    }

    writeFileSync(file, minified);
  }
}

/**
 * @argument { string } fileContents
 * @returns { string | null }
 */
function minifyJS(fileContents) {
  return terser_minify(fileContents, TERSER_OPTIONS).code ?? null;
}

/**
 * @argument { string } fileContents
 * @returns { Promise<string | null> }
 */
async function minifyHTML(fileContents) {
  return html_terser_minify(fileContents, HTML_TERSER_OPTIONS);
}

/**
 * @argument { string } fileContents
 * @returns { Promise<string | null> }
 */
async function minifyCSS(fileContents) {
  const newFileContents = `<style>${fileContents}</style>`;
  const minified = await html_terser_minify(
    newFileContents,
    HTML_TERSER_OPTIONS
  );

  return minified.slice(7, minified.length - 8);
}

async function main() {
  const buildDirectories = process.argv.slice(2);

  if (buildDirectories.length === 0) {
    console.error("No build directories selected");
    return;
  }

  for (const directory of buildDirectories) {
    await minify(directory).catch((error) => {
      const errorMessage =
        error instanceof Error ? error.message : JSON.stringify(error);

      console.error(`[minify] | Error: ${errorMessage}`);
    });
  }
}

main();
